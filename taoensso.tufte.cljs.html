<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.tufte documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tufte</span> <span class="project-version">2.6.0</span></span></a></h1><div id="langs"><div class="lang"><a href="index.clj.html">clj</a></div><div class="lang current">cljs</div></div></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2 current"><a href="taoensso.tufte.cljs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tufte</span></div></a></li><li class="depth-3"><a href="taoensso.tufte.timbre.cljs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timbre</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-*min-level*"><div class="inner"><span>*min-level*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-*ns-filter*"><div class="inner"><span>*ns-filter*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-add-accumulating-handler.21"><div class="inner"><span>add-accumulating-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-add-basic-println-handler.21"><div class="inner"><span>add-basic-println-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-add-handler.21"><div class="inner"><span>add-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-capture-time.21"><div class="inner"><span>capture-time!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-capture-time.21*"><div class="inner"><span>capture-time!*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-chance"><div class="inner"><span>chance</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-compile-ns-filter"><div class="inner"><span>compile-ns-filter</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-defnp"><div class="inner"><span>defnp</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-defnp-"><div class="inner"><span>defnp-</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-fnp"><div class="inner"><span>fnp</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-format-grouped-pstats"><div class="inner"><span>format-grouped-pstats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-format-id-abbr"><div class="inner"><span>format-id-abbr</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-format-pstats"><div class="inner"><span>format-pstats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-handlers_"><div class="inner"><span>handlers_</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-HandlerVal"><div class="inner"><span>HandlerVal</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-may-profile.3F"><div class="inner"><span>may-profile?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-merge-pstats"><div class="inner"><span>merge-pstats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-new-pdata"><div class="inner"><span>new-pdata</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-p"><div class="inner"><span>p</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-profile"><div class="inner"><span>profile</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-profiled"><div class="inner"><span>profiled</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-profiling.3F"><div class="inner"><span>profiling?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-pspy"><div class="inner"><span>pspy</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-remove-handler.21"><div class="inner"><span>remove-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-stats-accumulator"><div class="inner"><span>stats-accumulator</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-StatsAccumulator"><div class="inner"><span>StatsAccumulator</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.cljs.html#var-with-profiling"><div class="inner"><span>with-profiling</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.tufte</h1><div class="doc"><pre class="plaintext">A simple, fast, monitoring profiler for Clojure/Script.

Usage: wrap+name interesting body exprs with the `p` macro. Then activate
profiling of these wrapped exprs using the `profiled` or `profile` macros:

  (profiled {} (p :my-fn (my-fn))) ; Returns [&lt;body-result&gt; &lt;?pstats&gt;]
  (profile  {} (p :my-fn (my-fn))) ; Returns  &lt;body-result&gt;, dispatches
                                   ; ?pstats to any registered handlers.

Extensive facilities are provided for compile-time elision and runtime
filtering.

See the relevant docstrings for more info:
  `p`, `profiled`, `profile`, `add-handler!` ; Core API

  (p        [opts &amp; body] [id &amp; body]) ; e.g. `(p ::my-pid (do-work))`
  (profiled [opts &amp; body])             ; e.g. `(profiled {:level 2} (my-fn))`
  (profile  [opts &amp; body])             ; e.g. `(profiled {:level 2} (my-fn))`

  (add-handler! [handler-id ns-pattern handler-fn])

How/where to use this library:
  Tufte profiling is highly optimized: even without elision, you can usually
  leave profiling enabled in production (e.g. for sampled profiling, or to
  detect unusual performance behaviour). Tufte's stats maps are well suited
  to programmatic monitoring.

Abbreviations, etc.
  - form  id = pid = id given in `p`
  - group id = gid = id given in `profile`</pre></div><div class="public anchor" id="var-*min-level*"><h3>*min-level*</h3><h4 class="dynamic">dynamic</h4><h4 class="lang"><a href="taoensso.tufte.html#var-*min-level*">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Integer e/o #{0 1 2 3 4 5 6}, or vector mapping ns-patterns to min-levels:
  [[&lt;ns-pattern&gt; &lt;min-level&gt;] ... ["*" &lt;default-min-level&gt;]]

See `*ns-filter*` for example patterns.</pre></div></div><div class="public anchor" id="var-*ns-filter*"><h3>*ns-filter*</h3><h4 class="dynamic">dynamic</h4><h4 class="lang"><a href="taoensso.tufte.html#var-*ns-filter*">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"></div><div class="doc"><pre class="plaintext">(fn may-profile-ns? [ns]) predicate, or ns-pattern.
Example ns-patterns:
  #{}, "*", "foo.bar", "foo.bar.*", #{"foo" "bar.*"},
  {:allow #{"foo" "bar.*"} :deny #{"foo.*.bar.*"}}</pre></div></div><div class="public anchor" id="var-add-accumulating-handler.21"><h3>add-accumulating-handler!</h3><h4 class="lang"><a href="taoensso.tufte.html#var-add-accumulating-handler.21">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(add-accumulating-handler! {:keys [ns-pattern handler-id], :or {ns-pattern "*", handler-id :accumulating}})</code></div><div class="doc"><pre class="plaintext">Alpha, subject to change.

Creates a new StatsAccumulator (and agent in clj), then
registers a handler to accumulate `profile` output to the
StatsAccumulator using the agent.

Returns the StatsAccumulator. You can deref the result to
drain the accumulator and return {&lt;group-id&gt; &lt;merged-pstats&gt;}.

One common pattern is to deref the accumulator every n
minutes/etc. to get a view of total-system performance over
the period, e.g.:

(defonce my-sacc (add-accumulating-handler! {:ns-pattern "*"}))
(defonce my-sacc-drainer
  ;; Will drain and print formatted stats every minute
  (future
    (while true
      (when-let [m (not-empty @my-sacc)]
        (println (format-grouped-pstats m)))
      (Thread/sleep 60000))))

(profile ...) ; Used elsewhere in your application, e.g.
              ; wrapping relevant Ring routes in a web application.

See also `format-grouped-pstats`, example clj project.</pre></div></div><div class="public anchor" id="var-add-basic-println-handler.21"><h3>add-basic-println-handler!</h3><h4 class="lang"><a href="taoensso.tufte.html#var-add-basic-println-handler.21">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(add-basic-println-handler! {:keys [ns-pattern handler-id format-pstats-opts], :or {ns-pattern "*", handler-id :basic-println}})</code></div><div class="doc"><pre class="plaintext">Adds a simple handler that logs `profile` stats output with `println`.
</pre></div></div><div class="public anchor" id="var-add-handler.21"><h3>add-handler!</h3><h4 class="lang"><a href="taoensso.tufte.html#var-add-handler.21">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(add-handler! handler-id handler-fn)</code><code>(add-handler! handler-id ns-pattern handler-fn)</code></div><div class="doc"><pre class="plaintext">Use this to register interest in stats output produced by `profile` calls.
Each registered `handler-fn` will be called as:

  (handler-fn {:ns-str _ :level _ :?id _ :?data _ :pstats _ :pstats-str_ _})

Map args:
  :ns-str      - Namespace string where `profile` call took place
  :level       - Level e/o #{0 1 2 3 4 5}, given in `(profile {:level _} ...)`
  :?id         - Optional group id,        given in `(profile {:id    _} ...)`
  :?data       - Optional arb data,        given in `(profile {:data  _} ...)`
  :pstats      - As in `(second (profiled ...))`. Derefable, mergeable.
  :pstats-str_ - `(delay (format-pstats pstats))

Error handling (NB):
  Handler errors will be silently swallowed. Please `try`/`catch` and
  appropriately deal with (e.g. log) possible errors *within* `handler-fn`.

Async/blocking:
  `handler-fn` should ideally be non-blocking, or reasonably cheap. Handler
   dispatch occurs through a 1-thread 1k-buffer dropping queue.

Ns filtering:
  Provide an optional `ns-pattern` arg to only call handler for matching
  namespaces. See `*ns-filter*` for example patterns.

Handler ideas:
  Save to a db, log, `put!` to an appropriate `core.async` channel, filter,
  aggregate, use for a realtime analytics dashboard, examine for outliers
  or unexpected output, ...</pre></div></div><div class="public anchor" id="var-capture-time.21"><h3>capture-time!</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-capture-time.21">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(capture-time! pdata id nano-secs-elapsed)</code><code>(capture-time! id nano-secs-elapsed)</code></div><div class="doc"><pre class="plaintext">Note: this is a low-level primitive for advanced users!
Can be useful when tracking time across arbitrary thread boundaries or for
async jobs / callbacks / etc.

See `new-pdata` for more info on low-level primitives.
See also `capture-time!*`.</pre></div></div><div class="public anchor" id="var-capture-time.21*"><h3>capture-time!*</h3><h4 class="lang"><a href="taoensso.tufte.html#var-capture-time.21*">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(capture-time!* pdata id nano-secs-elapsed)</code><code>(capture-time!* id nano-secs-elapsed)</code></div><div class="doc"><pre class="plaintext">Like `capture-time!` but: a function, and does not collect callsite location info.
</pre></div></div><div class="public anchor" id="var-chance"><h3>chance</h3><h4 class="lang"><a href="taoensso.tufte.html#var-chance">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(chance p)</code></div><div class="doc"><pre class="plaintext">Returns true with 0&lt;`p`&lt;1 probability.
</pre></div></div><div class="public anchor" id="var-compile-ns-filter"><h3>compile-ns-filter</h3><h4 class="lang"><a href="taoensso.tufte.html#var-compile-ns-filter">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(compile-ns-filter ns-pattern)</code></div><div class="doc"><pre class="plaintext">Wraps `taoensso.encore/compile-str-filter`.
</pre></div></div><div class="public anchor" id="var-defnp"><h3>defnp</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-defnp">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(defnp name doc-string? attr-map? [params*] prepost-map? body)</code><code>(defnp name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</code></div><div class="doc"><pre class="plaintext">Like `defn` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-defnp-"><h3>defnp-</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-defnp-">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(defnp- name doc-string? attr-map? [params*] prepost-map? body)</code><code>(defnp- name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</code></div><div class="doc"><pre class="plaintext">Like `defn-` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-fnp"><h3>fnp</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-fnp">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(fnp name? [params*] prepost-map? body)</code><code>(fnp name? ([params*] prepost-map? body) +)</code></div><div class="doc"><pre class="plaintext">Like `fn` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-format-grouped-pstats"><h3>format-grouped-pstats</h3><h4 class="lang"><a href="taoensso.tufte.html#var-format-grouped-pstats">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(format-grouped-pstats m)</code><code>(format-grouped-pstats m {:keys [group-sort-fn format-pstats-opts], :or {group-sort-fn (fn [m] (get-in m [:clock :total] 0))}})</code></div><div class="doc"><pre class="plaintext">Alpha, subject to change.
Takes a map of {&lt;group-id&gt; &lt;PStats&gt;} and formats a combined
output string using `format-pstats`.

See also example clj project.</pre></div></div><div class="public anchor" id="var-format-id-abbr"><h3>format-id-abbr</h3><h4 class="lang"><a href="taoensso.tufte.html#var-format-id-abbr">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(format-id-abbr)</code><code>(format-id-abbr n)</code></div><div class="doc"><pre class="plaintext">Returns a cached (fn [id]) =&gt; abbreviated id string.
Takes `n` (default 1), the number of namespace parts to keep unabbreviated.

Examples:
  ((format-id-abbr)   :foo)                     =&gt; "foo"
  ((format-id-abbr)   :example.hello/foo)       =&gt; "e.hello/foo"
  ((format-id-abbr 1) :example.hello/foo)       =&gt; "e.hello/foo"
  ((format-id-abbr 1) :example.hello.world/foo) =&gt; "e.h.world/foo"
  ((format-id-abbr 2) :example.hello.world/foo) =&gt; "e.hello.world/foo"
  ((format-id-abbr 0) :example.hello.world/foo) =&gt; "e.h.w/foo"</pre></div></div><div class="public anchor" id="var-format-pstats"><h3>format-pstats</h3><h4 class="lang"><a href="taoensso.tufte.html#var-format-pstats">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(format-pstats ps)</code><code>(format-pstats ps opts)</code></div><div class="doc"><pre class="plaintext">Formats given pstats to a string table.
Accounted &lt; Clock =&gt; Some work was done that wasn't tracked by any p forms.
Accounted &gt; Clock =&gt; Nested p forms, and/or parallel threads.</pre></div></div><div class="public anchor" id="var-handlers_"><h3>handlers_</h3><h4 class="lang"><a href="taoensso.tufte.html#var-handlers_">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"></div><div class="doc"><pre class="plaintext">{&lt;handler-id&gt; &lt;handler-fn&gt;}
</pre></div></div><div class="public anchor" id="var-HandlerVal"><h3>HandlerVal</h3><h4 class="lang current">cljs</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-may-profile.3F"><h3>may-profile?</h3><h4 class="lang"><a href="taoensso.tufte.html#var-may-profile.3F">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(may-profile? level)</code><code>(may-profile? level ns)</code></div><div class="doc"><pre class="plaintext">Implementation detail.
Returns true iff level and ns are runtime unfiltered.</pre></div></div><div class="public anchor" id="var-merge-pstats"><h3>merge-pstats</h3><h4 class="lang"><a href="taoensso.tufte.html#var-merge-pstats">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(merge-pstats)</code><code>(merge-pstats ps0)</code><code>(merge-pstats ps0 ps1)</code></div><div class="doc"><pre class="plaintext">Statistics are lossless unless data to merge are very large.
</pre></div></div><div class="public anchor" id="var-new-pdata"><h3>new-pdata</h3><h4 class="lang"><a href="taoensso.tufte.html#var-new-pdata">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(new-pdata)</code><code>(new-pdata {:keys [dynamic? nmax], :or {dynamic? true, nmax default-nmax}})</code></div><div class="doc"><pre class="plaintext">Note: this is a low-level primitive for advanced users!
Returns a new pdata object for use with `with-profiling` and/or `capture-time!`.
Deref to get pstats:

  (let [pd (new-pdata)
        t0 (System/nanoTime)]
    (with-profiling pd {}
      (p :foo (Thread/sleep 100))
      (capture-time! pd :bar (- t0 (System/nanoTime))))
    (deref pd))

Dynamic (thread-safe) by default.
*WARNING*: don't change this default unless you're very sure the resulting
pdata object will not be concurrently modified across threads. Concurrent
modification will lead to bad data and/or exceptions!</pre></div></div><div class="public anchor" id="var-p"><h3>p</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-p">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(p id &amp; body)</code><code>(p opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Profiling spy. Always executes body, and always returns &lt;body-result&gt;.

When [ns level] unelided and profiling is active, records execution
time of body.

Compile-time opts:
 :id    - Form id for this body in stats output (e.g. `::my-fn-call`)
 :level - e/o #{0 1 2 3 4 5} ; Default is `5`</pre></div></div><div class="public anchor" id="var-profile"><h3>profile</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-profile">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(profile opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Always executes body, and always returns &lt;body-result&gt;.

When [ns level] unelided and [ns level `when`] unfiltered, executes body
with profiling active and dispatches stats to any registered handlers
(see `add-handler!`).

Handy if you'd like to consume/aggregate stats output later/elsewhere.
Otherwise see `profiled`.

Compile-time opts:
  :dynamic? - Use multi-threaded profiling? ; Default is `false`
  :nmax     - ~Max captures per id before compaction ; Default is 8e5

Runtime opts:
  :level    - e/o #{0 1 2 3 4 5} ; Default is `5`
  :when     - Optional arbitrary conditional form (e.g. boolean expr)
  :id       - Optional group id provided to handlers (e.g. `::my-stats-1`)
  :data     - Optional arbitrary data provided to handlers

Laziness in body:
  Lazy seqs and other forms of laziness (e.g. delays) in body will only
  contribute to profiling results if/when EVALUATION ACTUALLY OCCURS.
  This is intentional and a useful property. Compare:

  (profile {}  (delay (Thread/sleep 2000))) ; Doesn't count sleep
  (profile {} @(delay (Thread/sleep 2000))) ; Does    count sleep

Async code in body:
  Execution time of any code in body that runs asynchronously on a
  different thread will generally NOT be automatically captured by default.

  :dynamic? can be used to support capture in cases where Clojure's
  binding conveyance applies (e.g. futures, agents, pmap). Just make sure
  that all work you want to capture has COMPLETED before the `profiled`
  form ends- for example, by blocking on pending futures.

  In other advanced cases (notably core.async `go` blocks), please see
  `with-profiling` and `capture-time!`.

`core.async` warning:
   `core.async` code can be difficult to profile correctly without a deep
   understanding of precisely what it's doing under-the-covers.

   Some general recommendations that can help keep things simple:

     - Try minimize the amount of code + logic in `go` blocks. Use `go`
       blocks for un/parking to get the data you need, then pass the data
       to external fns. Profile these fns (or in these fns), not in your
       `go` blocks.

     - In particular: you MUST NEVER have parking calls inside
       `(profiled {:dynamic? false} ...)`.

       This can lead to concurrency exceptions.

       If you must profile code within a go block, and you really want to
       include un/parking times, use `(profiled {:dynamic? true} ...)`
       instead.</pre></div></div><div class="public anchor" id="var-profiled"><h3>profiled</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-profiled">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(profiled opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Always executes body, and always returns [&lt;body-result&gt; &lt;?pstats&gt;].

When [ns level] unelided and [ns level `when`] unfiltered, executes body
with profiling active.

Handy if you'd like to consume stats output directly.
Otherwise see `profile`.

`pstats` objects are derefable and mergeable:
  - @pstats                 =&gt; {:clock {:keys [t0 t1 total]}, :stats {&lt;id&gt; {:keys [n sum ...]}}}
  - @(merge-pstats ps1 ps2) =&gt; {:clock {:keys [t0 t1 total]}, :stats {&lt;id&gt; {:keys [n sum ...]}}}

Full set of keys in `:stats` maps:
  :n :min :max :mean :mad :sum :p25 :p50 :p75 :p90 :p95 :p99 :loc

  All values are numerical (longs or doubles), except for `:loc` which
  is a map of `p` callsite location information, e.g.:
    {:ns "my-ns", :file "/tmp/my-ns.clj", :line 122, :column 21}

Compile-time opts:
  :dynamic? - Use multi-threaded profiling? ; Default is `false`
  :nmax     - ~Max captures per id before compaction ; Default is 8e5

Runtime opts:
  :level    - e/o #{0 1 2 3 4 5} ; Default is `5`
  :when     - Optional arbitrary conditional form (e.g. boolean expr)

Laziness in body:
  Lazy seqs and other forms of laziness (e.g. delays) in body will only
  contribute to profiling results if/when EVALUATION ACTUALLY OCCURS.
  This is intentional and a useful property. Compare:

  (profiled {}  (delay (Thread/sleep 2000))) ; Doesn't count sleep
  (profiled {} @(delay (Thread/sleep 2000))) ; Does    count sleep

Async code in body:
  Execution time of any code in body that runs asynchronously on a
  different thread will generally NOT be automatically captured by default.

  :dynamic? can be used to support capture in cases where Clojure's
  binding conveyance applies (e.g. futures, agents, pmap). Just make sure
  that all work you want to capture has COMPLETED before the `profiled`
  form ends- for example, by blocking on pending futures.

  In other advanced cases (notably core.async `go` blocks), please see
  `with-profiling` and `capture-time!`.

`core.async` warning:
   `core.async` code can be difficult to profile correctly without a deep
   understanding of precisely what it's doing under-the-covers.

   Some general recommendations that can help keep things simple:

     - Try minimize the amount of code + logic in `go` blocks. Use `go`
       blocks for un/parking to get the data you need, then pass the data
       to external fns. Profile these fns (or in these fns), not in your
       `go` blocks.

     - In particular: you MUST NEVER have parking calls inside
       `(profiled {:dynamic? false} ...)`.

       This can lead to concurrency exceptions.

       If you must profile code within a go block, and you really want to
       include un/parking times, use `(profiled {:dynamic? true} ...)`
       instead.</pre></div></div><div class="public anchor" id="var-profiling.3F"><h3>profiling?</h3><h4 class="lang"><a href="taoensso.tufte.html#var-profiling.3F">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(profiling?)</code></div><div class="doc"><pre class="plaintext">Returns e/o #{nil :thread :dynamic}.
</pre></div></div><div class="public anchor" id="var-pspy"><h3>pspy</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-pspy">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(pspy &amp; args)</code></div><div class="doc"><pre class="plaintext">`p` alias
</pre></div></div><div class="public anchor" id="var-remove-handler.21"><h3>remove-handler!</h3><h4 class="lang"><a href="taoensso.tufte.html#var-remove-handler.21">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(remove-handler! handler-id)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-stats-accumulator"><h3>stats-accumulator</h3><h4 class="lang"><a href="taoensso.tufte.html#var-stats-accumulator">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(stats-accumulator)</code></div><div class="doc"><pre class="plaintext">Alpha, subject to change.
Small util to help merge pstats from multiple runs or threads.

Returns a stateful StatsAccumulator (`sacc`) with:
  - `(sacc &lt;group-id&gt; &lt;pstats&gt;)` ; Merges given pstats under given group id
  - `@sacc`                      ; Drains accumulator and returns {&lt;group-id&gt; &lt;merged-pstats&gt;}

Note that you may want some kind of async/buffer/serialization
mechanism in front of merge calls for performance (e.g. by using an agent).

See also `add-accumulating-handler!`, example clj project.</pre></div></div><div class="public anchor" id="var-StatsAccumulator"><h3>StatsAccumulator</h3><h4 class="lang current">cljs</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-with-profiling"><h3>with-profiling</h3><h4 class="type">macro</h4><h4 class="lang"><a href="taoensso.tufte.html#var-with-profiling">clj</a></h4><h4 class="lang current">cljs</h4><div class="usage"><code>(with-profiling pdata {:keys [dynamic? nmax], :or {nmax default-nmax}} &amp; body)</code></div><div class="doc"><pre class="plaintext">Note: this is a low-level primitive for advanced users!
Enables `p` forms in body and returns body's result.

If `:dynamic?` is false (default), body's evaluation MUST begin
and end without interruption on the same thread. In particular
this means that body MUST NOT contain any parking `core.async`
calls.

See `new-pdata` for more info on low-level primitives.</pre></div></div></div></body></html>